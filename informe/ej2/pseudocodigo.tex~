\subsection{Pseudocodigo y an\'alisis de complejidad}

La idea del algoritmo es ordenar los cursos según su tiempo de finalización de menor a mayor y luego recorrerlos e ir agrenando los cursos al resultado final siempre y cuando no se solape con el último curso agregado. Más adelante veremos que resolverlo de esta forma nos devuelve una solución óptima.

El algoritmo que resuelve el problema esta representado por el siguiente pseudocodigo:

%%dejo mostrarcusos y verGraficamente???
\begin{algorithm}[H]
\caption{Resolver}\label{resolver}
\begin{algorithmic}[1]
\Procedure{Resolver}{$n, cursos$}\Comment{n= cantidad de cursos, cursos= $tupla< <inicio,fin>, id >$}
	%\State $mostrarCursos$\Comment{Muestra los cursos de entrada}
	%\State $verGraficamente$\Comment{Los muestra de una manera mas amigable}
	\State $sort(cursos)$ \Comment{De menor a mayor de acuerdo al tiempo de finalización}
	\State $final \gets 0$
	\For{$ i \gets 0, i< cursos.size(),++i$}
	\If {$ cursos[i].first.first > final$}
		\State $ cursosRes.pushBack(cursos[i])$
		\State $final \gets cursos[i].first.second$
	\State \textbf{return} $cursosRes$
	\EndIf
	\EndFor 	
\EndProcedure		
\end{algorithmic}
\end{algorithm}

Pasemos a analizar la complejidad:

\begin{itemize}
  \item En la linea 2, usamos el algorimo sort definido en la biblioteca estandar de c++ (http://www.cplusplus.com/reference/algorithm/sort/?kw=sort).
Su complejidad es N*log2(N), donde n es la cantidad de elementos del vector de entrada.

  \item En la linea 4, el for realiza N iteraciones.
  \item Luego la complejidad total es $N*log2(N)$, estrictamente menor a $N^{2}$.

\end{itemize}


